{"ast":null,"code":"/**\r\n * Persists proctoring/audit events locally so they survive offline and page refresh.\r\n * Events are keyed by attemptId and sent to the backend when online; successful\r\n * sends remove them from storage to keep logs immutable and avoid duplicates.\r\n */\n\nconst STORAGE_KEY_PREFIX = \"proctor_pending_\";\nconst MAX_EVENTS_PER_ATTEMPT = 500;\nfunction getStorageKey(attemptId) {\n  return `${STORAGE_KEY_PREFIX}${attemptId}`;\n}\n\n/**\r\n * @param {string} attemptId\r\n * @returns {Array<{ id: string, eventType: string, timestamp: string, questionId: string | null, metadata: object }>}\r\n */\nexport function getPendingEvents(attemptId) {\n  if (!attemptId) return [];\n  try {\n    const raw = localStorage.getItem(getStorageKey(attemptId));\n    if (!raw) return [];\n    const list = JSON.parse(raw);\n    return Array.isArray(list) ? list : [];\n  } catch (e) {\n    console.warn(\"eventLogPersistence: getPendingEvents failed\", e);\n    return [];\n  }\n}\n\n/**\r\n * Append a single event to local storage for this attempt.\r\n * @param {string} attemptId\r\n * @param {{ id?: string, eventType: string, timestamp: string, questionId?: string | null, metadata?: object }} event\r\n */\nexport function appendEvent(attemptId, event) {\n  if (!attemptId) return;\n  try {\n    const list = getPendingEvents(attemptId);\n    const withId = {\n      ...event,\n      id: event.id || crypto.randomUUID()\n    };\n    list.push(withId);\n    if (list.length > MAX_EVENTS_PER_ATTEMPT) {\n      list.splice(0, list.length - MAX_EVENTS_PER_ATTEMPT);\n    }\n    localStorage.setItem(getStorageKey(attemptId), JSON.stringify(list));\n  } catch (e) {\n    console.warn(\"eventLogPersistence: appendEvent failed\", e);\n  }\n}\n\n/**\r\n * Remove events by id after successful send to backend.\r\n * @param {string} attemptId\r\n * @param {string[]} ids\r\n */\nexport function removeEventsById(attemptId, ids) {\n  if (!attemptId || !(ids !== null && ids !== void 0 && ids.length)) return;\n  try {\n    const set = new Set(ids);\n    const list = getPendingEvents(attemptId).filter(e => !set.has(e.id));\n    if (list.length === 0) {\n      localStorage.removeItem(getStorageKey(attemptId));\n    } else {\n      localStorage.setItem(getStorageKey(attemptId), JSON.stringify(list));\n    }\n  } catch (e) {\n    console.warn(\"eventLogPersistence: removeEventsById failed\", e);\n  }\n}\n\n/**\r\n * Build payload for backend from stored events (strip id for API).\r\n * @param {Array<{ id: string, eventType: string, timestamp: string, questionId?: string | null, metadata?: object }>} events\r\n * @returns {{ events: Array<{ eventType: string, timestamp: string, questionId?: string | null, metadata?: object }>, ids: string[] }}\r\n */\nexport function toBackendPayload(events) {\n  const ids = events.map(e => e.id);\n  const eventsForApi = events.map(({\n    id,\n    ...rest\n  }) => rest);\n  return {\n    events: eventsForApi,\n    ids\n  };\n}","map":{"version":3,"names":["STORAGE_KEY_PREFIX","MAX_EVENTS_PER_ATTEMPT","getStorageKey","attemptId","getPendingEvents","raw","localStorage","getItem","list","JSON","parse","Array","isArray","e","console","warn","appendEvent","event","withId","id","crypto","randomUUID","push","length","splice","setItem","stringify","removeEventsById","ids","set","Set","filter","has","removeItem","toBackendPayload","events","map","eventsForApi","rest"],"sources":["C:/Project/Online_Test_Project/Front-End/online_test/src/services/eventLogPersistence.js"],"sourcesContent":["/**\r\n * Persists proctoring/audit events locally so they survive offline and page refresh.\r\n * Events are keyed by attemptId and sent to the backend when online; successful\r\n * sends remove them from storage to keep logs immutable and avoid duplicates.\r\n */\r\n\r\nconst STORAGE_KEY_PREFIX = \"proctor_pending_\";\r\nconst MAX_EVENTS_PER_ATTEMPT = 500;\r\n\r\nfunction getStorageKey(attemptId) {\r\n  return `${STORAGE_KEY_PREFIX}${attemptId}`;\r\n}\r\n\r\n/**\r\n * @param {string} attemptId\r\n * @returns {Array<{ id: string, eventType: string, timestamp: string, questionId: string | null, metadata: object }>}\r\n */\r\nexport function getPendingEvents(attemptId) {\r\n  if (!attemptId) return [];\r\n  try {\r\n    const raw = localStorage.getItem(getStorageKey(attemptId));\r\n    if (!raw) return [];\r\n    const list = JSON.parse(raw);\r\n    return Array.isArray(list) ? list : [];\r\n  } catch (e) {\r\n    console.warn(\"eventLogPersistence: getPendingEvents failed\", e);\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Append a single event to local storage for this attempt.\r\n * @param {string} attemptId\r\n * @param {{ id?: string, eventType: string, timestamp: string, questionId?: string | null, metadata?: object }} event\r\n */\r\nexport function appendEvent(attemptId, event) {\r\n  if (!attemptId) return;\r\n  try {\r\n    const list = getPendingEvents(attemptId);\r\n    const withId = { ...event, id: event.id || crypto.randomUUID() };\r\n    list.push(withId);\r\n    if (list.length > MAX_EVENTS_PER_ATTEMPT) {\r\n      list.splice(0, list.length - MAX_EVENTS_PER_ATTEMPT);\r\n    }\r\n    localStorage.setItem(getStorageKey(attemptId), JSON.stringify(list));\r\n  } catch (e) {\r\n    console.warn(\"eventLogPersistence: appendEvent failed\", e);\r\n  }\r\n}\r\n\r\n/**\r\n * Remove events by id after successful send to backend.\r\n * @param {string} attemptId\r\n * @param {string[]} ids\r\n */\r\nexport function removeEventsById(attemptId, ids) {\r\n  if (!attemptId || !ids?.length) return;\r\n  try {\r\n    const set = new Set(ids);\r\n    const list = getPendingEvents(attemptId).filter((e) => !set.has(e.id));\r\n    if (list.length === 0) {\r\n      localStorage.removeItem(getStorageKey(attemptId));\r\n    } else {\r\n      localStorage.setItem(getStorageKey(attemptId), JSON.stringify(list));\r\n    }\r\n  } catch (e) {\r\n    console.warn(\"eventLogPersistence: removeEventsById failed\", e);\r\n  }\r\n}\r\n\r\n/**\r\n * Build payload for backend from stored events (strip id for API).\r\n * @param {Array<{ id: string, eventType: string, timestamp: string, questionId?: string | null, metadata?: object }>} events\r\n * @returns {{ events: Array<{ eventType: string, timestamp: string, questionId?: string | null, metadata?: object }>, ids: string[] }}\r\n */\r\nexport function toBackendPayload(events) {\r\n  const ids = events.map((e) => e.id);\r\n  const eventsForApi = events.map(({ id, ...rest }) => rest);\r\n  return { events: eventsForApi, ids };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}