{"ast":null,"code":"import axios from \"axios\";\nimport { appendEvent, getPendingEvents, removeEventsById, toBackendPayload } from \"./eventLogPersistence\";\nconst API_BASE = \"http://localhost:5000\";\n\n/**\r\n * Send event via sendBeacon so it is delivered even when the tab is throttled\r\n * (e.g. after exiting fullscreen or switching tab). Used for critical events\r\n * that must not be delayed by the browser.\r\n */\nfunction sendEventBeacon(attemptId, eventType, timestamp, questionId, metadata) {\n  if (typeof navigator === \"undefined\" || !navigator.sendBeacon) return;\n  const url = `${API_BASE}/api/attempt/${attemptId}/event`;\n  const body = JSON.stringify({\n    events: [{\n      eventType,\n      timestamp,\n      questionId,\n      metadata\n    }]\n  });\n  const blob = new Blob([body], {\n    type: \"application/json\"\n  });\n  navigator.sendBeacon(url, blob);\n}\nexport const logEvent = async ({\n  attemptId,\n  eventType,\n  questionId = null,\n  metadata = {}\n}, options = {}) => {\n  // console.log(\"QuestionId in logEvent\",questionId);\n\n  const {\n    useBeacon = false\n  } = options;\n  const timestamp = new Date().toISOString();\n  const id = typeof crypto !== \"undefined\" && crypto.randomUUID ? crypto.randomUUID() : `evt_${Date.now()}_${Math.random().toString(36).slice(2)}`;\n  const event = {\n    id,\n    eventType,\n    timestamp,\n    questionId,\n    metadata\n  };\n  appendEvent(attemptId, event);\n  if (useBeacon) {\n    console.log(\"BEAN LOG\");\n    sendEventBeacon(attemptId, eventType, timestamp, questionId, metadata);\n    return;\n  }\n  try {\n    const response = await axios.post(`${API_BASE}/api/attempt/${attemptId}/event`, {\n      events: [{\n        eventType,\n        timestamp,\n        questionId,\n        metadata\n      }]\n    });\n    removeEventsById(attemptId, [id]);\n    return response.data;\n  } catch (error) {\n    var _error$response;\n    console.error(\"Error logging event:\", ((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.data) || error.message);\n  }\n};\n\n/**\r\n * Flush events persisted locally (e.g. after offline or page refresh).\r\n * Call this when the test page loads so pending events are sent to the backend.\r\n */\nexport const flushPendingEvents = async attemptId => {\n  const pending = getPendingEvents(attemptId);\n  if (pending.length === 0) return;\n  const {\n    events,\n    ids\n  } = toBackendPayload(pending);\n  try {\n    await axios.post(`${API_BASE}/api/attempt/${attemptId}/event`, {\n      events\n    });\n    removeEventsById(attemptId, ids);\n  } catch (error) {\n    var _error$response2;\n    console.error(\"Flush pending events failed:\", ((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.data) || error.message);\n  }\n};\nexport const submitTest = async attemptId => {\n  try {\n    const response = await axios.post(`${API_BASE}/api/attempt/submit/${attemptId}`);\n    return response.data;\n  } catch (error) {\n    var _error$response3;\n    console.error(\"Submit failed:\", ((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : _error$response3.data) || error.message);\n    throw error;\n  }\n};\nexport const getAttemptById = async attemptId => {\n  const response = await axios.get(`${API_BASE}/api/attempt/${attemptId}`);\n  return response.data;\n};\nexport const getQuestions = async () => {\n  const response = await axios.get(`${API_BASE}/api/attempt/questions`);\n  return response.data;\n};\nexport const getAttemptAnswers = async attemptId => {\n  const response = await axios.get(`${API_BASE}/api/attempt/${attemptId}/answers`);\n  return response.data;\n};\nexport const saveAnswers = async (attemptId, answers) => {\n  const response = await axios.post(`${API_BASE}/api/attempt/${attemptId}/answers`, {\n    answers\n  });\n  return response.data;\n};","map":{"version":3,"names":["axios","appendEvent","getPendingEvents","removeEventsById","toBackendPayload","API_BASE","sendEventBeacon","attemptId","eventType","timestamp","questionId","metadata","navigator","sendBeacon","url","body","JSON","stringify","events","blob","Blob","type","logEvent","options","useBeacon","Date","toISOString","id","crypto","randomUUID","now","Math","random","toString","slice","event","console","log","response","post","data","error","_error$response","message","flushPendingEvents","pending","length","ids","_error$response2","submitTest","_error$response3","getAttemptById","get","getQuestions","getAttemptAnswers","saveAnswers","answers"],"sources":["C:/Project/Online_Test_Project/Front-End/online_test/src/services/api.js"],"sourcesContent":["import axios from \"axios\";\r\nimport {\r\n  appendEvent,\r\n  getPendingEvents,\r\n  removeEventsById,\r\n  toBackendPayload,\r\n} from \"./eventLogPersistence\";\r\n\r\nconst API_BASE = \"http://localhost:5000\";\r\n\r\n/**\r\n * Send event via sendBeacon so it is delivered even when the tab is throttled\r\n * (e.g. after exiting fullscreen or switching tab). Used for critical events\r\n * that must not be delayed by the browser.\r\n */\r\nfunction sendEventBeacon(attemptId, eventType, timestamp, questionId, metadata) {\r\n  if (typeof navigator === \"undefined\" || !navigator.sendBeacon) return;\r\n  const url = `${API_BASE}/api/attempt/${attemptId}/event`;\r\n  const body = JSON.stringify({\r\n    events: [{ eventType, timestamp, questionId, metadata }],\r\n  });\r\n  const blob = new Blob([body], { type: \"application/json\" });\r\n  navigator.sendBeacon(url, blob);\r\n}\r\n\r\nexport const logEvent = async (\r\n  {\r\n    attemptId,\r\n    eventType,\r\n    questionId = null,\r\n    metadata = {},\r\n  },\r\n  options = {}\r\n) => {\r\n  // console.log(\"QuestionId in logEvent\",questionId);\r\n  \r\n  const { useBeacon = false } = options;\r\n  const timestamp = new Date().toISOString();\r\n  const id =\r\n    typeof crypto !== \"undefined\" && crypto.randomUUID\r\n      ? crypto.randomUUID()\r\n      : `evt_${Date.now()}_${Math.random().toString(36).slice(2)}`;\r\n  const event = {\r\n    id,\r\n    eventType,\r\n    timestamp,\r\n    questionId,\r\n    metadata,\r\n  };\r\n\r\n  appendEvent(attemptId, event);\r\n\r\n  if (useBeacon) {\r\n    console.log(\"BEAN LOG\");\r\n    \r\n    sendEventBeacon(attemptId, eventType, timestamp, questionId, metadata);\r\n    return;\r\n  }\r\n\r\n  try {\r\n    const response = await axios.post(\r\n      `${API_BASE}/api/attempt/${attemptId}/event`,\r\n      { events: [{ eventType, timestamp, questionId, metadata }] },\r\n    );\r\n    removeEventsById(attemptId, [id]);\r\n    return response.data;\r\n  } catch (error) {\r\n    console.error(\r\n      \"Error logging event:\",\r\n      error.response?.data || error.message,\r\n    );\r\n  }\r\n};\r\n\r\n/**\r\n * Flush events persisted locally (e.g. after offline or page refresh).\r\n * Call this when the test page loads so pending events are sent to the backend.\r\n */\r\nexport const flushPendingEvents = async (attemptId) => {\r\n  const pending = getPendingEvents(attemptId);\r\n  if (pending.length === 0) return;\r\n\r\n  const { events, ids } = toBackendPayload(pending);\r\n  try {\r\n    await axios.post(\r\n      `${API_BASE}/api/attempt/${attemptId}/event`,\r\n      { events },\r\n    );\r\n    removeEventsById(attemptId, ids);\r\n  } catch (error) {\r\n    console.error(\r\n      \"Flush pending events failed:\",\r\n      error.response?.data || error.message,\r\n    );\r\n  }\r\n};\r\n\r\nexport const submitTest = async (attemptId) => {\r\n  try {\r\n    const response = await axios.post(\r\n      `${API_BASE}/api/attempt/submit/${attemptId}`,\r\n    );\r\n    return response.data;\r\n  } catch (error) {\r\n    console.error(\"Submit failed:\", error.response?.data || error.message);\r\n    throw error;\r\n  }\r\n};\r\n\r\nexport const getAttemptById = async (attemptId) => {\r\n  const response = await axios.get(\r\n    `${API_BASE}/api/attempt/${attemptId}`,\r\n  );\r\n  return response.data;\r\n};\r\n\r\nexport const getQuestions = async () => {\r\n  const response = await axios.get(`${API_BASE}/api/attempt/questions`);\r\n  return response.data;\r\n};\r\n\r\nexport const getAttemptAnswers = async (attemptId) => {\r\n  const response = await axios.get(\r\n    `${API_BASE}/api/attempt/${attemptId}/answers`,\r\n  );\r\n  return response.data;\r\n};\r\n\r\nexport const saveAnswers = async (attemptId, answers) => {\r\n  const response = await axios.post(\r\n    `${API_BASE}/api/attempt/${attemptId}/answers`,\r\n    { answers },\r\n  );\r\n  return response.data;\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}